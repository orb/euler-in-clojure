(ns euler.problem61)

;;Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
;;numbers are all figurate (polygonal) numbers and are generated by
;;the following formulae:

;; Triangle P3,n=n*(n+1)/2 1, 3, 6, 10, 15, ...
;; Square P4,n=n^2 1, 4, 9, 16, 25, ...
;; Pentagonal P5,n=n*(3n-1)/2 1, 5, 12, 22, 35, ...
;; Hexagonal P6,n=n*(2n-1) 1, 6, 15, 28, 45, ...
;; Heptagonal P7,n=n*(5n-3)/2 1, 7, 18, 34, 55, ...
;; Octagonal P8,n=n*(3n-2) 1, 8, 21, 40, 65, ...

;; The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
;; three interesting properties.

;; The set is cyclic, in that the last two digits of each number is
;; the first two digits of the next number (including the last number
;; with the first).

;; Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
;; and pentagonal (P5,44=2882), is represented by a different number
;; in the set.

;; This is the only set of 4-digit numbers with this property.

;; Find the sum of the only ordered set of six cyclic 4-digit numbers
;; for which each polygonal type: triangle, square, pentagonal,
;; hexagonal, heptagonal, and octagonal, is represented by a different
;; number in the set.

(defn square [n]
  (* n n))

(defn triangle [n]
  (/ (* n (inc n)) 2))

(defn pentagonal [n]
  (/ (* n (- (* 3 n) 1)) 2))

(defn hexagonal [n]
  (* n (- (* 2 n) 1)))

(defn heptagonal [n]
  (/ (* n (- (* n 5) 3)) 2))

(defn octagonal [n]
  (* n (- (* 3 n) 2)))

;; all the polygonal functions we are interested in
(def polygonal-fns
  [square triangle pentagonal hexagonal heptagonal octagonal])

;; a sequence of each polygonal function in the range of 4 digit numbers:
;; 1000 <= (f n) < 10000
(defn polygonal-seq [index]
  (->> (range)
       (map (polygonal-fns index))
       (drop-while #(< % 1000))
       (take-while #(< % 10000))))


;; a basic breadth first search using an extension function and a done predicate
;; each iteration pops a node off the queue and extends the queue with all paths
;; from that node until a done or no nodes are left.
(defn extend-bfs [nodes extend-fn done-fn]
    (when (seq nodes)
      (let [[current-node & rest-nodes] nodes]
        (if (done-fn current-node)
          current-node
          (recur (concat rest-nodes
                         (extend-fn current-node))
                 extend-fn
                 done-fn)))))

;; from a path, calculate the solution score, which is the 
(defn extract-solution-from-path [path]
  (reduce + (map second path)))


;; solve using breadth first search from all possible starting node
(defn solve []
  (let [starting-paths
        (for [val (polygonal-seq 0)]
          [[0 val]])

        ;; all the nodes that are not a starting point
        extension-nodes
        (for [n (range 1 (count polygonal-fns))
              val (polygonal-seq n)]
          [n val])


        ;; test if two nodes are linked, which is when the last two digits of the first
        ;; node are the first two digits of the last node
        linked-nodes?
        (fn [[_ num1] [_ num2]]
          (= (mod num1 100) (quot num2 100)))

        ;; test if a given node can extend the path, which is if it is linked and the
        ;; function has not been used on a prior path
        can-extend?
        (fn [path next-node]
          (let [fn-is-not-duplicate
                (fn []
                  (every? #(not= (first %) (first next-node))
                          path))
                
                path-is-continuation
                (fn []
                  (linked-nodes? (last path) next-node))]
            (and
             (path-is-continuation)
             (fn-is-not-duplicate))))

        ;; find all the possible extensions to the past from the original set of nodes
        ;; and filter according to whether or not they extend the path.  Could
        ;; probably be more efficient by not 
        path-extensions
        (fn  [path]
          (for [next-node extension-nodes
                :when (can-extend? path next-node)]
            (conj path next-node)))
        
        solved?
        (fn [path]
          (and (= (count polygonal-fns) (count path))
               (linked-nodes? (last path) (first path))))
        
        solved-path
        (extend-bfs starting-paths
                    path-extensions
                    solved?)]

    (println "path is" solved-path)
    (extract-solution-from-path solved-path)))